#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <list>

class Graph {
public:
    Graph() {}

    ~Graph() {}

    void addVertex(int v) {
        if (v < 0) {
            std::cout << "Invalid vertex index" << std::endl;
            return;
        }
        else if (v < Adjlist.size())
            std::cout << "Vertex " << v << " already exists." << std::endl;
        else
            Adjlist.resize(v + 1);
    }

    void addEdge(int source, int dest) {
        if (source < 0 || dest < 0) {
            std::cout << "Invalid vertex index" << std::endl;
            return;
        }
        else if (source >= Adjlist.size() || dest >= Adjlist.size()) {
            std::cout << "Invalid vertex index" << std::endl;
            return;
        }


        if (std::find(Adjlist[source].begin(), Adjlist[source].end(), dest) == Adjlist[source].end()) {
            Adjlist[source].push_back(dest);
        }
        /*if (std::find(Adjlist[dest].begin(), Adjlist[dest].end(), source) == Adjlist[dest].end()) {
            Adjlist[dest].push_back(source);
        } Commenting lines 38 - 40 makes graph Directed */
    }

    void printGraph() {
        for (int i = 0; i < Adjlist.size(); i++) {
            std::cout << i << " -> ";
            for (int j = 0; j < Adjlist[i].size(); j++)
                std::cout << Adjlist[i][j] << " /";
            std::cout << std::endl;
        }
    }

    void bfs(int source) {
        std::vector<char> visited(Adjlist.size(), 0);
        std::queue<int> queue;
        queue.push(source);
        visited[source] = 1;
        while (!queue.empty()) {
            int u = queue.front();
            std::cout << u << " / ";
            queue.pop();
            for (int v : Adjlist[u]) {
                if (visited[v] == 0) {
                    queue.push(v);
                    visited[v] = 1;
                }
            }
        }
    }

    void dfsIterative(int source) {
        std::vector<char> visited(Adjlist.size(), 0);
        std::stack<int> stack;
        stack.push(source);
        visited[source] = 1;
        while (!stack.empty()) {
            int u = stack.top();
            stack.pop();
            std::cout << u << " / ";
            for (int v : Adjlist[u]) {
                if (visited[v] == 0) {
                    stack.push(v);
                    visited[v] = 1;
                }
            }

        }
    }

    void dfsRecursive(int source) {
        std::vector<int> visited(Adjlist.size(), 0);
        int componentcount = 0;
        bool flag = 1;
        while (flag) {
            for (int i = 0; i < visited.size(); i++) {
                if (visited[i] == 0) {
                    dfsRecursivehelper(i, visited);
                    componentcount++;
                }
                else
                    flag = false;
            }
        }
        //std::cout << std::endl << "Count of components is - " << componentcount << std::endl;
    }

    void dfsRecursivehelper(int source, std::vector<int>& visited) {
        visited[source] = 1;
        std::cout << source << " / ";
        for (int v : Adjlist[source]) {
            if (visited[v] == 0) {
                dfsRecursivehelper(v, visited);
            }
        }
    }

    void transpose() {
        std::vector<std::vector<int>> templist(Adjlist.size());
        for (int i = 0; i < Adjlist.size(); i++) {
            for (int j = 0; j < Adjlist[i].size(); j++) {
                templist[Adjlist[i][j]].push_back(i);
            }
        }

        Adjlist.clear();
        Adjlist = templist;
        templist.clear();
    }

    std::list<int> shortestPath(int source, int dest) {
        std::vector<char> visited(Adjlist.size(), 0);
        std::queue<int> queue;
        std::vector<short> parents(Adjlist.size(), -1);
        queue.push(source);
        visited[source] = 1;
        while (!queue.empty()) {
            int u = queue.front();
            queue.pop();
            for (int v : Adjlist[u]) {
                if (parents[v] == -1)
                    parents[v] = u;
                if (v == dest)
                    break;
                if (visited[v] == 0) {
                    queue.push(v);
                    visited[v] = 1;
                }
            }
        }

        std::list<int> shortestpath;
        int olddest = dest;
        while (source != dest) {
            shortestpath.push_front(dest);
            dest = parents[dest];
        }
        shortestpath.push_front(source);

        for (auto v : shortestpath) {
            if (v != olddest)
                std::cout << v << "->";
            else
                std::cout << v;
        }
        return shortestpath;
    }

    int nthlevelnodecount(int level) {
        std::vector<char> visited(Adjlist.size(), 0);
        std::queue<int> queue;
        std::vector<short> levels(Adjlist.size(), 0);
        queue.push(0);
        visited[0] = 1;
        while (!queue.empty()) {
            int u = queue.front();
            queue.pop();
            for (int v : Adjlist[u]) {
                if (visited[v] == 0) {
                    levels[v] = levels[u] + 1;
                    queue.push(v);
                    visited[v] = 1;
                }
            }
        }

        int count = 0;
        std::cout << "Nodes in " << level << " level are ";
        for (int i = 0; i < levels.size(); i++) {
            if (levels[i] == level) {
                count++;
            }
        }
        std::cout << " / " << count << " / ";
        return count;
    }



    void allpossiblepathshelper(int source, int dest, std::vector<bool>& visited, std::vector<int>& current,
        std::vector<std::vector<int>>& allpaths) {
        current.push_back(source);
        visited[source] = 1;

        if (source == dest) {
            allpaths.push_back(current);
        }

        for (int v : Adjlist[source]) {
            if (visited[v] == 0) {
                allpossiblepathshelper(v, dest, visited, current, allpaths);
            }
        }

        visited[source] = 0;
        current.pop_back();
    }

    void allpossiblepaths(int source, int dest) {
        std::vector<bool> visited(Adjlist.size(), 0);
        std::vector<int> current;
        std::vector<std::vector<int>> allpaths;
        allpossiblepathshelper(source, dest, visited, current, allpaths);
        for (int i = 0; i < allpaths.size(); ++i) {
            for (int j = 0; j < allpaths[i].size(); ++j) {
                std::cout << allpaths[i][j] << "  ";
            }
            std::cout << std::endl;
        }
    }

    bool dfsisCycledUndirected(int source, int parent, std::vector<bool>& visited) {
        visited[source] = 1;
        for (int v : Adjlist[source]) {
            if (visited[v] == 0) {
                if (dfsisCycledUndirected(v, source, visited))
                    return true;
            }
            else if (v != parent)
                return true;
        }
        return false;
    }


    bool isCycledUndirected() {
        std::vector<bool> visited(Adjlist.size(), 0);
        int parent = -1;
        for (int i = 0; i < Adjlist.size(); ++i) {
            if (visited[i] == 0) {
                if (dfsisCycledUndirected(i, parent, visited))
                    return true;
            }
        }
        return false;
    }

    bool dfsisCycledDirected(int source, std::vector<bool>& visited, std::vector<bool>& recstack) {
        visited[source] = 1;
        recstack[source] = 1;
        for (int v : Adjlist[source]) {
            if (visited[v] == 0) {
                if (dfsisCycledDirected(v, visited, recstack))
                    return true;
            }
            else if (recstack[v])
                return true;
        }
        recstack[source] = 0;
        return false;
    }


    bool isCycledDirected() {
        std::vector<bool> visited(Adjlist.size(), 0);
        std::vector<bool> recstack(Adjlist.size(), 0);
        for (int i = 0; i < Adjlist.size(); ++i) {
            if (visited[i] == 0) {
                if (dfsisCycledDirected(i, visited, recstack))
                    return true;
            }
        }
        return false;
    }


    void dfstopSort(int source, std::vector<bool>& visited, std::list<int>& result) {
        visited[source] = 1;
        for (int v : Adjlist[source]) {
            if (visited[v] == 0)
                dfstopSort(v, visited, result);
        }
        result.push_front(source);
    }

    void topSort() {
        std::vector<bool> visited(Adjlist.size(), 0);
        std::list<int> result;
        if (isCycledDirected()) {
            std::cout << "Graph is cyclic, doesn't have top. sort" << std::endl;
            return;
        }
        for (int i = 0; i < Adjlist.size(); ++i) {
            if (visited[i] == 0) {
                dfstopSort(i, visited, result);
            }
        }

        for (int v : result)
            std::cout << v << " ";
    }

    void topSortKahn() {
        std::vector<int> inorder(Adjlist.size());
        std::vector<int> indegree(Adjlist.size());
        for (int i = 0; i < Adjlist.size(); ++i) {
            for (int v : Adjlist[i]) {
                indegree[v]++;
            }
        }

        std::queue<int> queue;
        int index = 0;
        for (int j = 0; j < indegree.size() && index < Adjlist.size(); ++j) {
            if (!indegree[j]) {
                queue.push(j);
                while (!queue.empty()) {
                    int u = queue.front();
                    queue.pop();
                    inorder[index++] = u;
                    for (int vertex : Adjlist[u]) {
                        --indegree[vertex];
                        if (!indegree[vertex]) {
                            queue.push(vertex);
                        }
                    }
                }
            }
        }

        if (index < inorder.size())
            std::cout << "Cycle detected" << std::endl;
        else {
            for (int v : inorder)
                std::cout << v << " ";
        }
    }

    void dfsSccKosaraju(int source, std::vector<bool> &visited, std::stack<int> &stack) {
        visited[source] = 1;
        for (int v : Adjlist[source]) {
            if (!visited[v])
                dfsSccKosaraju(v, visited, stack);
        }
        stack.push(source);
    }

    void dfscollectingScc(int source, std::vector<bool>& visited, std::vector<int> &currencscc) {
        visited[source] = 1;
        for (int v : Adjlist[source]) {
            if (!visited[v])
                dfscollectingScc(v, visited, currencscc);
        }
        currencscc.push_back(source);
    }

    void SccKosaraju() {
        std::vector<bool> visited(Adjlist.size());
        std::vector<std::vector<int>> Scc;
        int source = 0;
        std::stack<int> stack;
        dfsSccKosaraju(source, visited, stack);
        transpose();
        visited.assign(Adjlist.size(), false);
        std::vector<int> currentscc;
        while (!stack.empty()) {
            int u = stack.top();
            stack.pop();
            if (!visited[u]) {
                dfscollectingScc(u, visited, currentscc);
                Scc.push_back(currentscc);
                currentscc.clear();
            }
        }

        for (int i = 0; i < Scc.size(); ++i) {
            for (int j = 0; j < Scc[i].size(); ++j) {
                std::cout << Scc[i][j] << "  ";
            }
            std::cout << std::endl;
        }
        
        transpose();
    }



private:
    std::vector<std::vector<int>> Adjlist;
};


int main(){
    Graph g;
   /* g.addVertex(0);
    g.addVertex(1);
    g.addVertex(2);
    g.addVertex(3);
    g.addVertex(4);
    g.addVertex(5);
    g.addVertex(6);
    g.addVertex(7);
    g.addVertex(8);
    g.addVertex(9);
    g.addVertex(10);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(0, 3);
    g.addEdge(1, 4);
    g.addEdge(1, 7);
    g.addEdge(2, 4);
    g.addEdge(4, 7);
    g.addEdge(5, 8);
    g.addEdge(2, 5);
    g.addEdge(3, 6);
    g.addEdge(7, 8);
    g.addEdge(6, 9);
    g.addEdge(8, 10);
    g.addEdge(9, 10);*/

    // new one 
    /*g.addVertex(0);
    g.addVertex(1);
    g.addVertex(2);
    g.addVertex(3);
    g.addVertex(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);
    g.addEdge(2, 4);
    g.addEdge(3, 4);*/

    //DAG example
    /*g.addVertex(0);
    g.addVertex(1);
    g.addVertex(2);
    g.addVertex(3);
    g.addVertex(4);
    g.addVertex(5);
    g.addVertex(6);
    g.addVertex(7);

    g.addEdge(0, 1);
    g.addEdge(2, 0);
    g.addEdge(3, 1);
    g.addEdge(3, 7);
    g.addEdge(4, 1);
    g.addEdge(3, 4);
    g.addEdge(4, 0);
    g.addEdge(5, 2);
    g.addEdge(6, 3);
    g.addEdge(6, 5);
    g.addEdge(6, 7);
    g.addEdge(7, 4);
    g.addEdge(6, 2);*/

   /* g.addVertex(1);
    g.addVertex(2);
    g.addVertex(3);
    g.addVertex(4);
    g.addVertex(5);
    g.addVertex(6);
    g.addVertex(7);

    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 4);
    g.addEdge(2, 5);
    g.addEdge(3, 6);
    g.addEdge(6, 5);
    g.addEdge(4, 7);
    g.addEdge(5, 7);
    g.addEdge(6, 7);*/

    //graph with 6 SCC's
    /*g.addVertex(0);
    g.addVertex(1);
    g.addVertex(2);
    g.addVertex(3);
    g.addVertex(4);
    g.addVertex(5);
    g.addVertex(6);
    g.addVertex(7);
    g.addVertex(8);
    g.addVertex(9);
    g.addVertex(10);
    g.addVertex(11);
    g.addVertex(12);
    g.addVertex(13);
    g.addVertex(14);
    g.addVertex(15);
    
    g.addEdge(0, 2);
    g.addEdge(1, 0);
    g.addEdge(2, 1);
    g.addEdge(2, 4);
    g.addEdge(4, 3);
    g.addEdge(3, 2);
    g.addEdge(3, 12);
    g.addEdge(4, 13);
    g.addEdge(12, 13);
    g.addEdge(13, 15);
    g.addEdge(15, 14);
    g.addEdge(14, 12);
    g.addEdge(13, 14);
    g.addEdge(1, 5); 
    g.addEdge(4, 5);
    g.addEdge(5, 6);
    g.addEdge(5, 8);
    g.addEdge(6, 7);
    g.addEdge(7, 8);
    g.addEdge(8, 6);
    g.addEdge(8, 9);
    g.addEdge(5, 10);
    g.addEdge(10, 11);
    g.addEdge(11, 10);
    g.addEdge(10, 9);
    g.addEdge(15, 10);*/

    //g.printGraph();
    //g.bfs(0);
    //g.dfsIterative(10);
    //g.dfsRecursive(0);
    //g.tranpose();
    //g.shortestPath(0, 4);
    //g.nthlevelnodecount(2);
    //g.allpossiblepaths(2, 2);
    //std::cout << g.isCycledUndirected();
    //std::cout << g.isCycledDirected();
    //g.topSort();
    //g.topSortKahn();
    //g.SccKosaraju();
    return 0;
}


